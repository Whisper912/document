---
title: 深入理解Java虚拟机笔记(2)-gc垃圾回收
date: 2019-11-12 09:21:18
tags:
- gc
- JVM
categories:
- Java
---

### 哪些对象需要被回收？
由于程序计数器，虚拟机栈，本地方法栈都是线程私有的，随着线程的消亡而消亡，所以不用特意回收，我们需要关注的就是堆区和方法区的回收。</br>
那就需要判断哪些对象需要被回收，可以使用如下方法
* 引用计数法
    给对象添加一个程序计数器，有地方引用时＋1，引用失效时-1，当计数器为0时回收。</br>
    Java虚拟机没有使用这个方法，因为引用计数法很难解决对象间的相互引用问题。
* 可达性分析算法
    以GC Roots作为根节点，不可到达根节点的对象是不可用的，需要被回收。</br>
    在Java中，以下几种对象可作为GC Roots
    * 虚拟机栈中的引用(运行着的方法中的引用)
    * 方法区中静态属性引用的对象
    * 方法区中常量的引用
    * 本地方法栈中的JNI(Native 方法)引用的对象

#### 引用
Java中可将引用分为强引用(Strong Reference)、软引用(Soft Reference)、弱引用(Weak Reference)、虚引用(Phantom Reference)，引用强度依次减弱
* 强引用：平时普遍使用的类似"Object o = new Object()"，只要强引用存在，对象永远不会被GC回收。
* 软引用：系统发现内存快要溢出时，回收软引用。
* 弱引用：被弱引用关联的对象只能存活到下一次GC之前，当GC工作时，会被回收。
* 虚引用：虚引用完全不会对对象的生存构成影响，甚至无法获得对象的实例。设置虚引用是为了在这个对象回收时收到一个系统消息。

### 垃圾收集算法

#### 标记-清除(Mark-Sweep)算法
和名字一样，先标记所有需要清除的对象，然后回收这些对象。但是这样有两个问题，一是标记和清除这两个过程效率都不高，二是会产生大量内存碎片

#### 复制算法
将内存分为大小相等的两块区域，每次只使用其中的一块。当使用中的这一块无法继续分配内存了，就将这一块上所有存活的对象复制到到另一块，并且清空这一块内存。

HotSpot虚拟机采用这种方法来回收新生代。因为新生代中大部分对象都朝生夕死，所以两块区域不需要按照1:1分配。而是将内存按8:1:1分为一块Eden+两块Survivor。每次使用Eden和其中一块Survivor，当Eden区满时，将Eden和当前使用的Survivor中活着的对象复制到另一块空白的Survivor，且对象的年龄+1。

#### 标记整理(Mark-Compact)算法
当存活的对象较多时，不适用复制算法，因为需要复制大量对象。标记整理算法也是先标记存活的对象，然后将所有对象向一端移动，最后清理边端所有内存。

这篇文章关于[Java的垃圾回收算法](https://juejin.im/post/5c41d8166fb9a049b82ac23d)讲的很仔细

### HotSpot中的算法实现
#### 枚举根节点
在可达性分析中，需要从gc roots依次扫描存活结点。那就需要枚举所有根节点，这些根节点主要存在于静态变量，栈帧中的本地变量表。如果逐个检查这些地方的引用，时间代价太大。而且在可达性分析过程中，需要STW(Stop the world)，不然在分析过程中引用关系还在不断变化。

由于目前主流Java虚拟机是准确式gc，也就是说虚拟机知道某个位置上的某个数据的类型，类型是准确的。因此也就知道哪些地方是引用。在HotSpot中是用了一种叫OopMap的结构来存放一个对象内什么偏移量上是什么类型的数据

#### 安全点(Safe Point)
因为执行gc时需要stop the world，那需要选择一个合适的时间STW，而且STP时是通过OopMap(Ordinary object point map)来枚举根节点的，如果为每条指令都生成OopMap开销太大，那我们可以设置一些安全点，只在安全点生成OopMap。安全点太多，GC 过于频繁，增大运行时负荷；安全点太少，GC 等待时间太长。

* 一般会在如下几个位置选择安全点：
    1. 循环的末尾
    2. 方法临返回前
    3. 调用方法之后
    4. 抛异常的位置
    5. new对象时

* 为什么选定这些位置作为安全点：</br>
    主要的目的就是避免程序长时间无法进入 Safe Point。比如 JVM 在做 GC 之前要等所有的应用线程进入安全点，如果有一个线程一直没有进入安全点，就会导致 GC 时 JVM 停顿时间延长。比如这里，超大的循环导致执行 GC 等待时间过长。
* 如何让所有线程停止并进入安全点？
    1. 抢先式中断</br>
    gc发生时，首先把所有线程中断，如果发现某个线程不在安全点，就继续运行他直到到达安全点
    2. 主动式中断</br>
    gc需要中断所有线程时，不直接对线程操作，而是设置一个标志，让所有线程去轮询(poll)这个标志，标志为真时就中断。轮询标志和安全点是重合的。JVM采用主动式中断

#### 安全域(Safe Region)
当一些线程进入Sleep状态或者Blocked状态时，无法响应JVM的中断请求，如果gc时一直等待这些线程做出反应，时间代价太大，这时就需要安全域。安全域是指在一段区域内，引用关系不会发生改变，所以在这个区域内任何时间gc都是安全的。

当线程执行到安全域时，会标记自己进入了安全域，这样gc时，JVM不用去管这样的线程了；当线程要离开安全域时，线程会先去检查此时是否已经完成gc，如果完成了就继续执行离开安全域，如果没完成要等待完成后再离开安全域。

### 垃圾收集器
* Serial
* ParNew
* Parallel Scavenge
* Serial Old
* Parallel Old
* CMS
* G1


### 内存分配与内存回收
