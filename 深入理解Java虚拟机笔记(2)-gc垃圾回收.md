---
title: 深入理解Java虚拟机笔记(2)-gc垃圾回收
date: 2019-11-12 09:21:18
tags:
- gc
- JVM
categories:
- Java
---

### 哪些对象需要被回收？
由于程序计数器，虚拟机栈，本地方法栈都是线程私有的，随着线程的消亡而消亡，所以不用特意回收，我们需要关注的就是堆区和方法区的回收。</br>
那就需要判断哪些对象需要被回收，可以使用如下方法
* 引用计数法
    给对象添加一个程序计数器，有地方引用时＋1，引用失效时-1，当计数器为0时回收。</br>
    Java虚拟机没有使用这个方法，因为引用计数法很难解决对象间的相互引用问题。
* 可达性分析算法
    以GC Roots作为根节点，不可到达根节点的对象是不可用的，需要被回收。</br>
    在Java中，以下几种对象可作为GC Roots
    * 虚拟机栈中的引用(运行着的方法中的引用)
    * 方法区中静态属性引用的对象
    * 方法区中常量的引用
    * 本地方法栈中的JNI(Native 方法)引用的对象

#### 引用
Java中可将引用分为强引用(Strong Reference)、软引用(Soft Reference)、弱引用(Weak Reference)、虚引用(Phantom Reference)，引用强度依次减弱
* 强引用：平时普遍使用的类似"Object o = new Object()"，只要强引用存在，对象永远不会被GC回收。
* 软引用：系统发现内存快要溢出时，回收软引用。
* 弱引用：被弱引用关联的对象只能存活到下一次GC之前，当GC工作时，会被回收。
* 虚引用：虚引用完全不会对对象的生存构成影响，甚至无法获得对象的实例。设置虚引用是为了在这个对象回收时收到一个系统消息。

### 垃圾收集算法

#### 标记-清除(Mark-Sweep)算法
和名字一样，先标记所有需要清除的对象，然后回收这些对象。但是这样有两个问题，一是标记和清除这两个过程效率都不高，二是会产生大量内存碎片

#### 复制算法
将内存分为大小相等的两块区域，每次只使用其中的一块。当使用中的这一块无法继续分配内存了，就将这一块上所有存活的对象复制到到另一块，并且清空这一块内存。

HotSpot虚拟机采用这种方法来回收新生代。因为新生代中大部分对象都朝生夕死，所以两块区域不需要按照1:1分配。而是将内存按8:1:1分为一块Eden+两块Survivor。每次使用Eden和其中一块Survivor，当Eden区满时，将Eden和当前使用的Survivor中活着的对象复制到另一块空白的Survivor，且对象的年龄+1。

#### 标记整理(Mark-Compact)算法
当存活的对象较多时，不适用复制算法，因为需要复制大量对象。标记整理算法也是先标记存活的对象，然后将所有对象向一端移动，最后清理边端所有内存。

这篇文章关于[Java的垃圾回收算法](https://juejin.im/post/5c41d8166fb9a049b82ac23d)讲的很仔细

### HotSpot中的算法实现
#### 枚举根节点
在可达性分析中，需要从gc roots依次扫描存活结点。那就需要枚举所有根节点，这些根节点主要存在于静态变量，栈帧中的本地变量表。如果逐个检查这些地方的引用，时间代价太大。而且在可达性分析过程中，需要STW(Stop the world)，不然在分析过程中引用关系还在不断变化。

由于目前主流Java虚拟机是准确式gc，也就是说虚拟机知道某个位置上的某个数据的类型，类型是准确的。因此也就知道哪些地方是引用。在HotSpot中是用了一种叫OopMap的结构来存放一个对象内什么偏移量上是什么类型的数据